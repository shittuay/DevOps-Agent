"""Penetration testing tools for DevOps Agent."""
import subprocess
import json
import time
import ipaddress
from typing import Dict, Any, List, Optional
from ..utils import get_logger


logger = get_logger(__name__)


class PentestValidator:
    """Validates pentest operations for authorization and safety."""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize pentest validator.

        Args:
            config: Pentest configuration with whitelists and restrictions
        """
        self.config = config or {}
        self.whitelisted_targets = self.config.get('whitelisted_targets', [])
        self.require_confirmation = self.config.get('require_confirmation', True)
        self.max_scan_intensity = self.config.get('max_scan_intensity', 4)
        self.prohibited_scan_types = self.config.get('prohibited_scan_types', ['dos', 'flood'])

    def validate_target(self, target: str) -> Dict[str, Any]:
        """
        Validate if target is authorized for scanning.

        Args:
            target: Target IP, hostname, or URL

        Returns:
            Validation result with authorization status
        """
        # If no whitelist configured, allow any target (assume user has authorization)
        if not self.whitelisted_targets:
            logger.warning("No target whitelist configured - assuming authorization")
            return {
                'authorized': True,
                'reason': 'No whitelist configured',
                'requires_confirmation': self.require_confirmation
            }

        # Check if target is in whitelist
        for allowed_target in self.whitelisted_targets:
            # Check for exact match or CIDR range
            try:
                # Try to parse as IP or CIDR
                if '/' in allowed_target:
                    # CIDR range
                    network = ipaddress.ip_network(allowed_target, strict=False)
                    target_ip = ipaddress.ip_address(target)
                    if target_ip in network:
                        return {
                            'authorized': True,
                            'reason': f'Target in whitelisted CIDR range: {allowed_target}',
                            'requires_confirmation': self.require_confirmation
                        }
                elif allowed_target == target or allowed_target in target:
                    # Exact match or substring match for domains
                    return {
                        'authorized': True,
                        'reason': f'Target matches whitelist: {allowed_target}',
                        'requires_confirmation': self.require_confirmation
                    }
            except ValueError:
                # Not a valid IP, try string matching
                if allowed_target == target or allowed_target in target:
                    return {
                        'authorized': True,
                        'reason': f'Target matches whitelist: {allowed_target}',
                        'requires_confirmation': self.require_confirmation
                    }

        # Target not authorized
        return {
            'authorized': False,
            'reason': f'Target not in whitelist: {target}',
            'requires_confirmation': False
        }

    def validate_scan_options(self, scan_type: str, intensity: int = 4) -> Dict[str, Any]:
        """
        Validate scan options for safety compliance.

        Args:
            scan_type: Type of scan being performed
            intensity: Scan intensity level (1-5)

        Returns:
            Validation result
        """
        # Check prohibited scan types
        if scan_type.lower() in self.prohibited_scan_types:
            return {
                'allowed': False,
                'reason': f'Scan type prohibited: {scan_type}'
            }

        # Check intensity limits
        if intensity > self.max_scan_intensity:
            return {
                'allowed': False,
                'reason': f'Scan intensity {intensity} exceeds maximum {self.max_scan_intensity}'
            }

        return {
            'allowed': True,
            'reason': 'Scan options within allowed parameters'
        }


def log_pentest_activity(
    operation: str,
    target: str,
    parameters: Dict[str, Any],
    result: Dict[str, Any]
) -> None:
    """
    Log penetration testing activity for audit trail.

    Args:
        operation: Type of operation performed
        target: Target of the operation
        parameters: Parameters used
        result: Result of the operation
    """
    audit_entry = {
        'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
        'operation': operation,
        'target': target,
        'parameters': parameters,
        'success': result.get('success', False),
        'findings_count': len(result.get('findings', [])),
        'execution_time_ms': result.get('execution_time_ms', 0)
    }

    logger.info(f"PENTEST_AUDIT: {json.dumps(audit_entry)}", extra={'audit': True})


# ===== NETWORK SCANNING TOOLS =====

def nmap_port_scan(
    target: str,
    ports: Optional[str] = None,
    scan_type: str = 'tcp',
    timing: int = 4,
    validator_config: Optional[Dict[str, Any]] = None,
    quick: bool = False
) -> Dict[str, Any]:
    """
    Perform network port scanning using nmap.

    Args:
        target: Target IP address or hostname
        ports: Port specification (e.g., '1-1000', '22,80,443', or 'all')
        scan_type: Scan type (tcp, syn, udp, service)
        timing: Timing template (0-5, lower is slower/stealthier)
        validator_config: Pentest validation configuration
        quick: Quick scan mode (top 100 ports, faster timing)

    Returns:
        Scan results with open ports and services
    """
    start_time = time.time()

    # Validate target
    validator = PentestValidator(validator_config)
    auth_result = validator.validate_target(target)

    if not auth_result['authorized']:
        return {
            'success': False,
            'error': 'Unauthorized target',
            'message': auth_result['reason'],
            'target': target
        }

    # Validate scan options
    scan_validation = validator.validate_scan_options('port_scan', timing)
    if not scan_validation['allowed']:
        return {
            'success': False,
            'error': 'Scan options not allowed',
            'message': scan_validation['reason']
        }

    logger.info(f"Starting nmap port scan on target: {target}")

    # Build nmap command
    scan_flags = {
        'syn': '-sS',
        'tcp': '-sT',
        'udp': '-sU',
        'service': '-sV'
    }

    # Quick mode: scan top 100 ports with faster timing
    if quick:
        port_spec = '--top-ports 100'
        timing = min(timing + 1, 5)  # Increase speed
        nmap_cmd = ['nmap', scan_flags.get(scan_type, '-sT'), port_spec, f'-T{timing}', target]
    else:
        port_spec = ports or '--top-ports 1000'
        if ports and ports != 'all':
            port_spec = f'-p {ports}'
        elif ports == 'all':
            port_spec = '-p-'

        nmap_cmd = ['nmap', scan_flags.get(scan_type, '-sT'), f'-T{timing}', target]
        if port_spec.startswith('-p') or port_spec.startswith('--'):
            nmap_cmd.insert(2, port_spec)

    # Determine timeout based on scan scope
    if quick:
        timeout = 180  # 3 minutes for quick scans
    elif ports == 'all':
        timeout = 1800  # 30 minutes for full port scan
    else:
        timeout = 600  # 10 minutes for default scans

    try:
        result = subprocess.run(
            nmap_cmd,
            capture_output=True,
            text=True,
            timeout=timeout
        )

        execution_time_ms = int((time.time() - start_time) * 1000)

        if result.returncode == 0:
            # Parse nmap output (simplified - in production use python-nmap library)
            findings = parse_nmap_output(result.stdout)

            response = {
                'success': True,
                'target': target,
                'scan_type': scan_type,
                'ports_scanned': port_spec,
                'findings': findings,
                'execution_time_ms': execution_time_ms,
                'raw_output': result.stdout
            }

            log_pentest_activity('nmap_port_scan', target,
                               {'scan_type': scan_type, 'ports': port_spec}, response)

            return response
        else:
            error_msg = result.stderr or 'Nmap scan failed'
            logger.error(f"Nmap scan failed: {error_msg}")
            return {
                'success': False,
                'error': error_msg,
                'target': target,
                'execution_time_ms': execution_time_ms
            }

    except subprocess.TimeoutExpired:
        return {
            'success': False,
            'error': 'Scan timed out after 30 minutes',
            'target': target
        }
    except FileNotFoundError:
        return {
            'success': False,
            'error': 'nmap not installed. Install with: apt-get install nmap (Linux) or brew install nmap (macOS)',
            'target': target
        }
    except Exception as e:
        logger.error(f"Nmap scan error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e),
            'target': target
        }


def nmap_service_detection(
    target: str,
    ports: Optional[str] = None,
    aggressive: bool = False,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Perform service version detection and OS fingerprinting.

    Args:
        target: Target IP address or hostname
        ports: Port specification (default: top 1000 ports)
        aggressive: Enable aggressive scanning (-A flag)
        validator_config: Pentest validation configuration

    Returns:
        Service detection results
    """
    start_time = time.time()

    validator = PentestValidator(validator_config)
    auth_result = validator.validate_target(target)

    if not auth_result['authorized']:
        return {
            'success': False,
            'error': 'Unauthorized target',
            'message': auth_result['reason']
        }

    logger.info(f"Starting service detection on target: {target}")

    nmap_cmd = ['nmap', '-sV']

    if aggressive:
        nmap_cmd.append('-A')

    if ports:
        nmap_cmd.extend(['-p', ports])

    nmap_cmd.extend(['-oX', '-', target])

    try:
        result = subprocess.run(
            nmap_cmd,
            capture_output=True,
            text=True,
            timeout=3600  # 1 hour max for service detection
        )

        execution_time_ms = int((time.time() - start_time) * 1000)

        if result.returncode == 0:
            findings = parse_nmap_service_output(result.stdout)

            response = {
                'success': True,
                'target': target,
                'services_detected': findings,
                'execution_time_ms': execution_time_ms,
                'raw_output': result.stdout
            }

            log_pentest_activity('service_detection', target,
                               {'aggressive': aggressive}, response)

            return response
        else:
            return {
                'success': False,
                'error': result.stderr or 'Service detection failed',
                'target': target
            }

    except Exception as e:
        logger.error(f"Service detection error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e),
            'target': target
        }


# ===== VULNERABILITY SCANNING TOOLS =====

def nikto_web_scan(
    target_url: str,
    ssl: bool = False,
    tuning: Optional[str] = None,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Perform web server vulnerability scan using Nikto.

    Args:
        target_url: Target web server URL
        ssl: Force SSL mode
        tuning: Scan tuning options (e.g., '1' for interesting files, '2' for misconfigurations)
        validator_config: Pentest validation configuration

    Returns:
        Vulnerability scan results
    """
    start_time = time.time()

    validator = PentestValidator(validator_config)
    auth_result = validator.validate_target(target_url)

    if not auth_result['authorized']:
        return {
            'success': False,
            'error': 'Unauthorized target',
            'message': auth_result['reason']
        }

    logger.info(f"Starting Nikto scan on: {target_url}")

    nikto_cmd = ['nikto', '-h', target_url, '-Format', 'json']

    if ssl:
        nikto_cmd.append('-ssl')

    if tuning:
        nikto_cmd.extend(['-Tuning', tuning])

    try:
        result = subprocess.run(
            nikto_cmd,
            capture_output=True,
            text=True,
            timeout=3600
        )

        execution_time_ms = int((time.time() - start_time) * 1000)

        # Nikto may return non-zero even on success
        vulnerabilities = parse_nikto_output(result.stdout)

        response = {
            'success': True,
            'target': target_url,
            'vulnerabilities_found': len(vulnerabilities),
            'vulnerabilities': vulnerabilities,
            'execution_time_ms': execution_time_ms,
            'raw_output': result.stdout
        }

        log_pentest_activity('nikto_scan', target_url, {'ssl': ssl}, response)

        return response

    except FileNotFoundError:
        return {
            'success': False,
            'error': 'Nikto not installed. Install from: https://github.com/sullo/nikto',
            'target': target_url
        }
    except Exception as e:
        logger.error(f"Nikto scan error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e),
            'target': target_url
        }


def ssl_scan(
    target: str,
    port: int = 443,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Scan SSL/TLS configuration for vulnerabilities.

    Args:
        target: Target hostname or IP
        port: SSL/TLS port (default 443)
        validator_config: Pentest validation configuration

    Returns:
        SSL/TLS security analysis
    """
    start_time = time.time()

    validator = PentestValidator(validator_config)
    auth_result = validator.validate_target(target)

    if not auth_result['authorized']:
        return {
            'success': False,
            'error': 'Unauthorized target',
            'message': auth_result['reason']
        }

    logger.info(f"Starting SSL/TLS scan on {target}:{port}")

    # Use testssl.sh or sslscan
    ssl_cmd = ['sslscan', '--json=-', f'{target}:{port}']

    try:
        result = subprocess.run(
            ssl_cmd,
            capture_output=True,
            text=True,
            timeout=300
        )

        execution_time_ms = int((time.time() - start_time) * 1000)

        if result.returncode == 0:
            findings = parse_ssl_scan_output(result.stdout)

            response = {
                'success': True,
                'target': f'{target}:{port}',
                'ssl_findings': findings,
                'execution_time_ms': execution_time_ms
            }

            log_pentest_activity('ssl_scan', target, {'port': port}, response)

            return response
        else:
            return {
                'success': False,
                'error': result.stderr or 'SSL scan failed',
                'target': f'{target}:{port}'
            }

    except FileNotFoundError:
        return {
            'success': False,
            'error': 'sslscan not installed. Install with: apt-get install sslscan',
            'target': f'{target}:{port}'
        }
    except Exception as e:
        logger.error(f"SSL scan error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e),
            'target': f'{target}:{port}'
        }


# ===== WEB APPLICATION TESTING TOOLS =====

def sqlmap_scan(
    target_url: str,
    data: Optional[str] = None,
    cookie: Optional[str] = None,
    risk_level: int = 1,
    batch: bool = True,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Test for SQL injection vulnerabilities using sqlmap.

    Args:
        target_url: Target URL to test
        data: POST data
        cookie: Cookie string
        risk_level: Risk level (1-3, default 1 for safe)
        batch: Never ask for user input
        validator_config: Pentest validation configuration

    Returns:
        SQL injection test results
    """
    start_time = time.time()

    validator = PentestValidator(validator_config)
    auth_result = validator.validate_target(target_url)

    if not auth_result['authorized']:
        return {
            'success': False,
            'error': 'Unauthorized target',
            'message': auth_result['reason']
        }

    # Validate risk level
    if risk_level > 2:
        return {
            'success': False,
            'error': 'Risk level limited to 2 for safety',
            'message': 'High risk SQL injection tests may cause service disruption'
        }

    logger.info(f"Starting sqlmap scan on: {target_url}")

    sqlmap_cmd = ['sqlmap', '-u', target_url, f'--risk={risk_level}', '--level=1']

    if batch:
        sqlmap_cmd.append('--batch')

    if data:
        sqlmap_cmd.extend(['--data', data])

    if cookie:
        sqlmap_cmd.extend(['--cookie', cookie])

    try:
        result = subprocess.run(
            sqlmap_cmd,
            capture_output=True,
            text=True,
            timeout=1800
        )

        execution_time_ms = int((time.time() - start_time) * 1000)

        vulnerabilities = parse_sqlmap_output(result.stdout)

        response = {
            'success': True,
            'target': target_url,
            'sql_injection_found': len(vulnerabilities) > 0,
            'vulnerabilities': vulnerabilities,
            'execution_time_ms': execution_time_ms,
            'raw_output': result.stdout
        }

        log_pentest_activity('sqlmap_scan', target_url,
                           {'risk_level': risk_level}, response)

        return response

    except FileNotFoundError:
        return {
            'success': False,
            'error': 'sqlmap not installed. Install from: https://github.com/sqlmapproject/sqlmap',
            'target': target_url
        }
    except Exception as e:
        logger.error(f"SQLmap scan error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e),
            'target': target_url
        }


def zap_spider_scan(
    target_url: str,
    max_depth: int = 5,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Spider a web application using OWASP ZAP.

    Args:
        target_url: Target URL to spider
        max_depth: Maximum crawl depth
        validator_config: Pentest validation configuration

    Returns:
        Spider scan results with discovered URLs
    """
    start_time = time.time()

    validator = PentestValidator(validator_config)
    auth_result = validator.validate_target(target_url)

    if not auth_result['authorized']:
        return {
            'success': False,
            'error': 'Unauthorized target',
            'message': auth_result['reason']
        }

    logger.info(f"Starting ZAP spider on: {target_url}")

    # Note: This requires ZAP to be running in daemon mode
    # In production, you'd use ZAP API

    try:
        # Placeholder - actual implementation would use ZAP Python API
        response = {
            'success': True,
            'target': target_url,
            'message': 'ZAP spider requires ZAP daemon. Use ZAP API for full implementation.',
            'urls_discovered': [],
            'execution_time_ms': int((time.time() - start_time) * 1000)
        }

        log_pentest_activity('zap_spider', target_url,
                           {'max_depth': max_depth}, response)

        return response

    except Exception as e:
        logger.error(f"ZAP spider error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e),
            'target': target_url
        }


def xss_scan(
    target_url: str,
    parameters: Optional[List[str]] = None,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Test for Cross-Site Scripting (XSS) vulnerabilities.

    Args:
        target_url: Target URL to test
        parameters: Specific parameters to test
        validator_config: Pentest validation configuration

    Returns:
        XSS vulnerability test results
    """
    start_time = time.time()

    validator = PentestValidator(validator_config)
    auth_result = validator.validate_target(target_url)

    if not auth_result['authorized']:
        return {
            'success': False,
            'error': 'Unauthorized target',
            'message': auth_result['reason']
        }

    logger.info(f"Starting XSS scan on: {target_url}")

    # Use XSStrike or similar tool
    xss_cmd = ['xsstrike', '-u', target_url, '--crawl']

    try:
        result = subprocess.run(
            xss_cmd,
            capture_output=True,
            text=True,
            timeout=1800
        )

        execution_time_ms = int((time.time() - start_time) * 1000)

        vulnerabilities = parse_xss_output(result.stdout)

        response = {
            'success': True,
            'target': target_url,
            'xss_found': len(vulnerabilities) > 0,
            'vulnerabilities': vulnerabilities,
            'execution_time_ms': execution_time_ms
        }

        log_pentest_activity('xss_scan', target_url, {}, response)

        return response

    except FileNotFoundError:
        return {
            'success': False,
            'error': 'XSStrike not installed. Manual XSS testing recommended.',
            'target': target_url,
            'message': 'Use manual testing or install XSStrike from: https://github.com/s0md3v/XSStrike'
        }
    except Exception as e:
        logger.error(f"XSS scan error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e),
            'target': target_url
        }


# ===== CLOUD SECURITY AUDITING TOOLS =====

def aws_security_audit(
    region: Optional[str] = None,
    services: Optional[List[str]] = None,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Audit AWS security posture and identify misconfigurations.

    Args:
        region: AWS region to audit (default: all regions)
        services: Specific AWS services to audit (ec2, s3, iam, etc.)
        validator_config: Pentest validation configuration

    Returns:
        AWS security audit results
    """
    start_time = time.time()

    logger.info(f"Starting AWS security audit for region: {region or 'all'}")

    try:
        import boto3
        from botocore.exceptions import ClientError

        findings = []
        services_to_check = services or ['s3', 'ec2', 'iam', 'rds']

        # S3 bucket security audit
        if 's3' in services_to_check:
            s3_client = boto3.client('s3', region_name=region)

            try:
                buckets = s3_client.list_buckets()['Buckets']

                for bucket in buckets:
                    bucket_name = bucket['Name']

                    # Check public access
                    try:
                        acl = s3_client.get_bucket_acl(Bucket=bucket_name)

                        for grant in acl['Grants']:
                            if grant['Grantee'].get('URI') == 'http://acs.amazonaws.com/groups/global/AllUsers':
                                findings.append({
                                    'service': 's3',
                                    'resource': bucket_name,
                                    'severity': 'HIGH',
                                    'finding': 'Bucket is publicly accessible',
                                    'recommendation': 'Restrict bucket ACL to authorized users only'
                                })
                    except ClientError:
                        pass

                    # Check encryption
                    try:
                        encryption = s3_client.get_bucket_encryption(Bucket=bucket_name)
                    except ClientError as e:
                        if e.response['Error']['Code'] == 'ServerSideEncryptionConfigurationNotFoundError':
                            findings.append({
                                'service': 's3',
                                'resource': bucket_name,
                                'severity': 'MEDIUM',
                                'finding': 'Bucket encryption not enabled',
                                'recommendation': 'Enable default encryption for the bucket'
                            })

                    # Check versioning
                    try:
                        versioning = s3_client.get_bucket_versioning(Bucket=bucket_name)
                        if versioning.get('Status') != 'Enabled':
                            findings.append({
                                'service': 's3',
                                'resource': bucket_name,
                                'severity': 'LOW',
                                'finding': 'Bucket versioning not enabled',
                                'recommendation': 'Enable versioning for data protection'
                            })
                    except ClientError:
                        pass

            except ClientError as e:
                logger.error(f"S3 audit error: {str(e)}")

        # EC2 security group audit
        if 'ec2' in services_to_check:
            ec2_client = boto3.client('ec2', region_name=region or 'us-east-1')

            try:
                security_groups = ec2_client.describe_security_groups()['SecurityGroups']

                for sg in security_groups:
                    sg_id = sg['GroupId']
                    sg_name = sg['GroupName']

                    # Check for overly permissive rules
                    for permission in sg.get('IpPermissions', []):
                        for ip_range in permission.get('IpRanges', []):
                            if ip_range.get('CidrIp') == '0.0.0.0/0':
                                from_port = permission.get('FromPort', 'all')
                                to_port = permission.get('ToPort', 'all')

                                severity = 'CRITICAL' if from_port in [22, 3389] else 'HIGH'

                                findings.append({
                                    'service': 'ec2',
                                    'resource': f'{sg_name} ({sg_id})',
                                    'severity': severity,
                                    'finding': f'Security group allows unrestricted access from 0.0.0.0/0 on ports {from_port}-{to_port}',
                                    'recommendation': 'Restrict access to specific IP ranges'
                                })

            except ClientError as e:
                logger.error(f"EC2 audit error: {str(e)}")

        # IAM audit
        if 'iam' in services_to_check:
            iam_client = boto3.client('iam')

            try:
                # Check for users with old access keys
                users = iam_client.list_users()['Users']

                for user in users:
                    username = user['UserName']
                    access_keys = iam_client.list_access_keys(UserName=username)['AccessKeyMetadata']

                    for key in access_keys:
                        key_age_days = (time.time() - key['CreateDate'].timestamp()) / 86400

                        if key_age_days > 90:
                            findings.append({
                                'service': 'iam',
                                'resource': username,
                                'severity': 'MEDIUM',
                                'finding': f'Access key is {int(key_age_days)} days old',
                                'recommendation': 'Rotate access keys regularly (every 90 days)'
                            })

                # Check for root account usage
                credential_report = iam_client.generate_credential_report()

            except ClientError as e:
                logger.error(f"IAM audit error: {str(e)}")

        execution_time_ms = int((time.time() - start_time) * 1000)

        response = {
            'success': True,
            'cloud_provider': 'aws',
            'region': region or 'all',
            'services_audited': services_to_check,
            'findings_count': len(findings),
            'findings': findings,
            'execution_time_ms': execution_time_ms
        }

        log_pentest_activity('aws_security_audit', region or 'all',
                           {'services': services_to_check}, response)

        return response

    except ImportError:
        return {
            'success': False,
            'error': 'boto3 not installed',
            'message': 'Install with: pip install boto3'
        }
    except Exception as e:
        logger.error(f"AWS security audit error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e)
        }


def azure_security_audit(
    subscription_id: Optional[str] = None,
    resource_groups: Optional[List[str]] = None,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Audit Azure security posture and identify misconfigurations.

    Args:
        subscription_id: Azure subscription ID
        resource_groups: Specific resource groups to audit
        validator_config: Pentest validation configuration

    Returns:
        Azure security audit results
    """
    start_time = time.time()

    logger.info(f"Starting Azure security audit for subscription: {subscription_id or 'default'}")

    try:
        # This would use Azure SDK (azure-mgmt-*) packages
        findings = []

        # Placeholder for Azure security checks
        # - Network Security Groups (NSGs) with overly permissive rules
        # - Storage accounts without encryption
        # - VMs without disk encryption
        # - Key Vault access policies
        # - Azure AD users without MFA

        execution_time_ms = int((time.time() - start_time) * 1000)

        response = {
            'success': True,
            'cloud_provider': 'azure',
            'subscription_id': subscription_id,
            'findings_count': len(findings),
            'findings': findings,
            'execution_time_ms': execution_time_ms,
            'message': 'Azure security audit implementation requires azure-mgmt-* packages'
        }

        log_pentest_activity('azure_security_audit', subscription_id or 'default',
                           {'resource_groups': resource_groups}, response)

        return response

    except Exception as e:
        logger.error(f"Azure security audit error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e)
        }


def gcp_security_audit(
    project_id: Optional[str] = None,
    services: Optional[List[str]] = None,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Audit GCP security posture and identify misconfigurations.

    Args:
        project_id: GCP project ID
        services: Specific GCP services to audit
        validator_config: Pentest validation configuration

    Returns:
        GCP security audit results
    """
    start_time = time.time()

    logger.info(f"Starting GCP security audit for project: {project_id or 'default'}")

    try:
        # This would use Google Cloud Client Libraries
        findings = []

        # Placeholder for GCP security checks
        # - Cloud Storage buckets with public access
        # - Firewall rules with 0.0.0.0/0
        # - Compute instances without encryption
        # - IAM permissions audit
        # - Service accounts with excessive permissions

        execution_time_ms = int((time.time() - start_time) * 1000)

        response = {
            'success': True,
            'cloud_provider': 'gcp',
            'project_id': project_id,
            'findings_count': len(findings),
            'findings': findings,
            'execution_time_ms': execution_time_ms,
            'message': 'GCP security audit implementation requires google-cloud-* packages'
        }

        log_pentest_activity('gcp_security_audit', project_id or 'default',
                           {'services': services}, response)

        return response

    except Exception as e:
        logger.error(f"GCP security audit error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e)
        }


def kubernetes_security_audit(
    namespace: Optional[str] = None,
    context: Optional[str] = None,
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Audit Kubernetes cluster security configuration.

    Args:
        namespace: Kubernetes namespace to audit
        context: Kubernetes context to use
        validator_config: Pentest validation configuration

    Returns:
        Kubernetes security audit results
    """
    start_time = time.time()

    logger.info(f"Starting Kubernetes security audit for namespace: {namespace or 'all'}")

    try:
        from kubernetes import client, config

        # Load kube config
        if context:
            config.load_kube_config(context=context)
        else:
            config.load_kube_config()

        findings = []
        v1 = client.CoreV1Api()
        apps_v1 = client.AppsV1Api()

        # Check pods running as root
        namespaces = [namespace] if namespace else [ns.metadata.name for ns in v1.list_namespace().items]

        for ns in namespaces:
            pods = v1.list_namespaced_pod(ns).items

            for pod in pods:
                # Check security context
                for container in pod.spec.containers:
                    if container.security_context:
                        if container.security_context.run_as_user == 0:
                            findings.append({
                                'resource': f'{pod.metadata.name}/{container.name}',
                                'namespace': ns,
                                'severity': 'HIGH',
                                'finding': 'Container running as root (UID 0)',
                                'recommendation': 'Set runAsUser to non-root UID in securityContext'
                            })

                        if not container.security_context.read_only_root_filesystem:
                            findings.append({
                                'resource': f'{pod.metadata.name}/{container.name}',
                                'namespace': ns,
                                'severity': 'MEDIUM',
                                'finding': 'Container has writable root filesystem',
                                'recommendation': 'Set readOnlyRootFilesystem: true'
                            })

                    # Check for privileged containers
                    if container.security_context and container.security_context.privileged:
                        findings.append({
                            'resource': f'{pod.metadata.name}/{container.name}',
                            'namespace': ns,
                            'severity': 'CRITICAL',
                            'finding': 'Container running in privileged mode',
                            'recommendation': 'Remove privileged: true unless absolutely necessary'
                        })

            # Check services
            services = v1.list_namespaced_service(ns).items

            for service in services:
                if service.spec.type == 'LoadBalancer':
                    findings.append({
                        'resource': service.metadata.name,
                        'namespace': ns,
                        'severity': 'MEDIUM',
                        'finding': 'Service exposed via LoadBalancer',
                        'recommendation': 'Review if public exposure is necessary'
                    })

        execution_time_ms = int((time.time() - start_time) * 1000)

        response = {
            'success': True,
            'platform': 'kubernetes',
            'namespace': namespace or 'all',
            'findings_count': len(findings),
            'findings': findings,
            'execution_time_ms': execution_time_ms
        }

        log_pentest_activity('kubernetes_security_audit', namespace or 'all',
                           {'context': context}, response)

        return response

    except ImportError:
        return {
            'success': False,
            'error': 'kubernetes Python client not installed',
            'message': 'Install with: pip install kubernetes'
        }
    except Exception as e:
        logger.error(f"Kubernetes security audit error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e)
        }


# ===== OUTPUT PARSERS =====

def parse_nmap_output(output: str) -> List[Dict[str, Any]]:
    """Parse nmap XML output into structured findings."""
    findings = []

    # Simplified parser - in production use xml.etree or python-nmap
    import re

    # Extract open ports
    port_pattern = r'(\d+)/(\w+)\s+open\s+(\w+)'
    matches = re.findall(port_pattern, output)

    for port, protocol, service in matches:
        findings.append({
            'port': int(port),
            'protocol': protocol,
            'service': service,
            'state': 'open'
        })

    return findings


def parse_nmap_service_output(output: str) -> List[Dict[str, Any]]:
    """Parse nmap service detection output."""
    findings = []

    # Simplified - parse service versions
    import re

    service_pattern = r'(\d+)/(\w+)\s+open\s+(\w+)\s+(.*)'
    matches = re.findall(service_pattern, output)

    for port, protocol, service, version in matches:
        findings.append({
            'port': int(port),
            'protocol': protocol,
            'service': service,
            'version': version.strip()
        })

    return findings


def parse_nikto_output(output: str) -> List[Dict[str, Any]]:
    """Parse Nikto output into vulnerabilities."""
    vulnerabilities = []

    # Parse Nikto findings
    import re

    finding_pattern = r'\+\s+(.*?):\s+(.*)'
    matches = re.findall(finding_pattern, output)

    for category, description in matches:
        vulnerabilities.append({
            'category': category.strip(),
            'description': description.strip(),
            'tool': 'nikto'
        })

    return vulnerabilities


def parse_ssl_scan_output(output: str) -> Dict[str, Any]:
    """Parse SSL scan output."""
    findings = {
        'protocols': [],
        'ciphers': [],
        'vulnerabilities': []
    }

    # Parse SSL/TLS protocols and vulnerabilities
    # Simplified - actual implementation would parse JSON from sslscan

    return findings


def parse_sqlmap_output(output: str) -> List[Dict[str, Any]]:
    """Parse sqlmap output for SQL injection findings."""
    vulnerabilities = []

    # Look for injection indicators
    if 'sqlmap identified' in output.lower() or 'parameter' in output.lower() and 'vulnerable' in output.lower():
        import re

        # Extract parameter and injection type
        param_pattern = r"Parameter:\s+(\S+)"
        type_pattern = r"Type:\s+(\S+)"

        param_match = re.search(param_pattern, output)
        type_match = re.search(type_pattern, output)

        if param_match or type_match:
            vulnerabilities.append({
                'parameter': param_match.group(1) if param_match else 'unknown',
                'injection_type': type_match.group(1) if type_match else 'unknown',
                'tool': 'sqlmap'
            })

    return vulnerabilities


def parse_xss_output(output: str) -> List[Dict[str, Any]]:
    """Parse XSS scanner output."""
    vulnerabilities = []

    # Look for XSS indicators
    if 'xss' in output.lower() and 'found' in output.lower():
        vulnerabilities.append({
            'type': 'xss',
            'description': 'Potential XSS vulnerability detected',
            'tool': 'xsstrike'
        })

    return vulnerabilities


# ===== COMPREHENSIVE SCAN FUNCTIONS =====

def quick_vulnerability_scan(
    target: str,
    scan_type: str = 'web',
    validator_config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Perform a quick vulnerability scan optimized for speed.

    Args:
        target: Target hostname, IP, or URL
        scan_type: Type of scan ('web', 'network', 'comprehensive')
        validator_config: Pentest validation configuration

    Returns:
        Consolidated scan results
    """
    start_time = time.time()

    # Validate target
    validator = PentestValidator(validator_config)
    auth_result = validator.validate_target(target)

    if not auth_result['authorized']:
        return {
            'success': False,
            'error': 'Unauthorized target',
            'message': auth_result['reason'],
            'target': target
        }

    logger.info(f"Starting quick vulnerability scan on target: {target}")

    results = {
        'target': target,
        'scan_type': scan_type,
        'scans_performed': [],
        'findings': [],
        'summary': {}
    }

    try:
        if scan_type == 'network':
            # Quick network scan - top 100 ports only
            logger.info("Performing quick port scan...")
            port_scan = nmap_port_scan(
                target=target,
                quick=True,
                validator_config=validator_config
            )

            if port_scan.get('success'):
                results['scans_performed'].append('port_scan')
                results['findings'].extend([
                    {
                        'type': 'open_port',
                        'severity': 'INFO',
                        'port': finding['port'],
                        'service': finding.get('service', 'unknown')
                    }
                    for finding in port_scan.get('findings', [])
                ])

        elif scan_type == 'web':
            # Quick web security scan
            # Check if URL or needs http://
            if not target.startswith(('http://', 'https://')):
                target_url = f'https://{target}'
            else:
                target_url = target

            # SSL scan (fast)
            logger.info("Checking SSL/TLS configuration...")
            ssl_result = ssl_scan(
                target=target.replace('https://', '').replace('http://', '').split('/')[0],
                validator_config=validator_config
            )

            if ssl_result.get('success'):
                results['scans_performed'].append('ssl_scan')
                ssl_findings = ssl_result.get('ssl_findings', {})
                if ssl_findings.get('vulnerabilities'):
                    results['findings'].extend([
                        {
                            'type': 'ssl_vulnerability',
                            'severity': 'HIGH',
                            'description': vuln
                        }
                        for vuln in ssl_findings['vulnerabilities']
                    ])

            # Quick nikto scan (limited checks)
            logger.info("Running web vulnerability scan...")
            nikto_result = nikto_web_scan(
                target_url=target_url,
                tuning='1,2',  # Only interesting files and misconfigurations
                validator_config=validator_config
            )

            if nikto_result.get('success'):
                results['scans_performed'].append('nikto_scan')
                for vuln in nikto_result.get('vulnerabilities', []):
                    results['findings'].append({
                        'type': 'web_vulnerability',
                        'severity': 'MEDIUM',
                        'category': vuln.get('category'),
                        'description': vuln.get('description')
                    })

        elif scan_type == 'comprehensive':
            # Comprehensive but still optimized scan
            logger.info("Running comprehensive scan (this may take a few minutes)...")

            # Port scan
            port_scan = nmap_port_scan(
                target=target,
                ports='--top-ports 200',
                timing=4,
                validator_config=validator_config
            )

            if port_scan.get('success'):
                results['scans_performed'].append('port_scan')
                for finding in port_scan.get('findings', []):
                    results['findings'].append({
                        'type': 'open_port',
                        'severity': 'INFO',
                        'port': finding['port'],
                        'service': finding.get('service')
                    })

            # Web checks if HTTP/HTTPS ports are open
            open_ports = [f['port'] for f in port_scan.get('findings', [])]
            if any(p in open_ports for p in [80, 443, 8080, 8443]):
                target_url = f'https://{target}' if 443 in open_ports else f'http://{target}'

                # SSL if HTTPS
                if 443 in open_ports or 8443 in open_ports:
                    ssl_result = ssl_scan(target=target, validator_config=validator_config)
                    if ssl_result.get('success'):
                        results['scans_performed'].append('ssl_scan')

                # Web vulnerability scan
                nikto_result = nikto_web_scan(
                    target_url=target_url,
                    validator_config=validator_config
                )
                if nikto_result.get('success'):
                    results['scans_performed'].append('nikto_scan')
                    results['findings'].extend([
                        {
                            'type': 'web_vulnerability',
                            'severity': 'MEDIUM',
                            'description': vuln.get('description')
                        }
                        for vuln in nikto_result.get('vulnerabilities', [])
                    ])

        # Generate summary
        execution_time_ms = int((time.time() - start_time) * 1000)

        results['summary'] = {
            'total_findings': len(results['findings']),
            'critical': sum(1 for f in results['findings'] if f.get('severity') == 'CRITICAL'),
            'high': sum(1 for f in results['findings'] if f.get('severity') == 'HIGH'),
            'medium': sum(1 for f in results['findings'] if f.get('severity') == 'MEDIUM'),
            'low': sum(1 for f in results['findings'] if f.get('severity') == 'LOW'),
            'info': sum(1 for f in results['findings'] if f.get('severity') == 'INFO'),
        }

        results['success'] = True
        results['execution_time_ms'] = execution_time_ms
        results['execution_time_readable'] = f"{execution_time_ms / 1000:.1f} seconds"

        log_pentest_activity('quick_vulnerability_scan', target,
                           {'scan_type': scan_type}, results)

        return results

    except subprocess.TimeoutExpired:
        return {
            'success': False,
            'error': 'Scan timed out',
            'message': 'Quick scan exceeded time limit. Try targeting specific services.',
            'target': target,
            'partial_results': results
        }
    except Exception as e:
        logger.error(f"Quick scan error: {str(e)}", exc_info=True)
        return {
            'success': False,
            'error': str(e),
            'target': target,
            'partial_results': results
        }


# ===== TOOL DEFINITIONS =====

def get_tools() -> List[Dict[str, Any]]:
    """
    Get tool definitions for penetration testing.

    Returns:
        List of tool definitions
    """
    return [
        # Network Scanning
        {
            'name': 'nmap_port_scan',
            'description': (
                'Perform network port scanning using nmap. '
                'Scans target hosts for open ports and services. '
                'Use quick=true for fast scans (top 100 ports, 2-3 minutes). '
                'Use quick=false for thorough scans (may take 10+ minutes). '
                'IMPORTANT: Only use on authorized targets. Requires explicit authorization. '
                'Will validate target against whitelist before execution.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'target': {
                        'type': 'string',
                        'description': 'Target IP address or hostname to scan'
                    },
                    'ports': {
                        'type': 'string',
                        'description': 'Port specification (e.g., "1-1000", "22,80,443", or "all"). Ignored if quick=true.'
                    },
                    'scan_type': {
                        'type': 'string',
                        'description': 'Scan type: tcp (default, no root needed), syn (faster, needs root), udp, or service',
                        'enum': ['tcp', 'syn', 'udp', 'service'],
                        'default': 'tcp'
                    },
                    'timing': {
                        'type': 'integer',
                        'description': 'Timing template (0-5, lower is slower/stealthier)',
                        'default': 4,
                        'minimum': 0,
                        'maximum': 5
                    },
                    'quick': {
                        'type': 'boolean',
                        'description': 'Quick scan mode - scans top 100 ports only for faster results',
                        'default': False
                    }
                },
                'required': ['target']
            },
            'handler': nmap_port_scan
        },
        {
            'name': 'nmap_service_detection',
            'description': (
                'Perform service version detection and OS fingerprinting using nmap. '
                'Identifies services and their versions running on open ports. '
                'IMPORTANT: Only use on authorized targets.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'target': {
                        'type': 'string',
                        'description': 'Target IP address or hostname'
                    },
                    'ports': {
                        'type': 'string',
                        'description': 'Port specification (default: top 1000 ports)'
                    },
                    'aggressive': {
                        'type': 'boolean',
                        'description': 'Enable aggressive scanning (-A flag)',
                        'default': False
                    }
                },
                'required': ['target']
            },
            'handler': nmap_service_detection
        },

        # Vulnerability Scanning
        {
            'name': 'nikto_web_scan',
            'description': (
                'Perform web server vulnerability scanning using Nikto. '
                'Tests for common web server vulnerabilities, misconfigurations, and security issues. '
                'IMPORTANT: Only use on authorized web servers.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'target_url': {
                        'type': 'string',
                        'description': 'Target web server URL (e.g., http://example.com)'
                    },
                    'ssl': {
                        'type': 'boolean',
                        'description': 'Force SSL mode',
                        'default': False
                    },
                    'tuning': {
                        'type': 'string',
                        'description': 'Scan tuning (1=interesting files, 2=misconfigurations, etc.)'
                    }
                },
                'required': ['target_url']
            },
            'handler': nikto_web_scan
        },
        {
            'name': 'ssl_scan',
            'description': (
                'Scan SSL/TLS configuration for vulnerabilities and weak ciphers. '
                'Tests protocol versions, cipher suites, and certificate validity. '
                'IMPORTANT: Only use on authorized targets.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'target': {
                        'type': 'string',
                        'description': 'Target hostname or IP address'
                    },
                    'port': {
                        'type': 'integer',
                        'description': 'SSL/TLS port (default: 443)',
                        'default': 443
                    }
                },
                'required': ['target']
            },
            'handler': ssl_scan
        },

        # Web Application Testing
        {
            'name': 'sqlmap_scan',
            'description': (
                'Test for SQL injection vulnerabilities using sqlmap. '
                'Automatically detects and exploits SQL injection flaws. '
                'CRITICAL: Only use on authorized applications with explicit permission. '
                'Risk level is limited to 2 for safety.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'target_url': {
                        'type': 'string',
                        'description': 'Target URL to test for SQL injection'
                    },
                    'data': {
                        'type': 'string',
                        'description': 'POST data (if testing POST parameters)'
                    },
                    'cookie': {
                        'type': 'string',
                        'description': 'Cookie string for authenticated testing'
                    },
                    'risk_level': {
                        'type': 'integer',
                        'description': 'Risk level (1-2, limited for safety)',
                        'default': 1,
                        'minimum': 1,
                        'maximum': 2
                    },
                    'batch': {
                        'type': 'boolean',
                        'description': 'Never ask for user input',
                        'default': True
                    }
                },
                'required': ['target_url']
            },
            'handler': sqlmap_scan
        },
        {
            'name': 'xss_scan',
            'description': (
                'Test for Cross-Site Scripting (XSS) vulnerabilities. '
                'Identifies reflected, stored, and DOM-based XSS flaws. '
                'IMPORTANT: Only use on authorized applications.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'target_url': {
                        'type': 'string',
                        'description': 'Target URL to test for XSS'
                    },
                    'parameters': {
                        'type': 'array',
                        'description': 'Specific parameters to test',
                        'items': {'type': 'string'}
                    }
                },
                'required': ['target_url']
            },
            'handler': xss_scan
        },
        {
            'name': 'zap_spider_scan',
            'description': (
                'Spider a web application using OWASP ZAP. '
                'Crawls the application to discover URLs and attack surface. '
                'IMPORTANT: Only use on authorized applications.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'target_url': {
                        'type': 'string',
                        'description': 'Target URL to spider'
                    },
                    'max_depth': {
                        'type': 'integer',
                        'description': 'Maximum crawl depth',
                        'default': 5
                    }
                },
                'required': ['target_url']
            },
            'handler': zap_spider_scan
        },

        # Cloud Security Auditing
        {
            'name': 'aws_security_audit',
            'description': (
                'Audit AWS security posture and identify misconfigurations. '
                'Checks S3 buckets, EC2 security groups, IAM policies, and more. '
                'Identifies public access, unencrypted resources, and compliance issues.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'region': {
                        'type': 'string',
                        'description': 'AWS region to audit (default: all regions)'
                    },
                    'services': {
                        'type': 'array',
                        'description': 'Specific AWS services to audit',
                        'items': {
                            'type': 'string',
                            'enum': ['s3', 'ec2', 'iam', 'rds', 'lambda', 'cloudtrail']
                        }
                    }
                },
                'required': []
            },
            'handler': aws_security_audit
        },
        {
            'name': 'azure_security_audit',
            'description': (
                'Audit Azure security posture and identify misconfigurations. '
                'Checks Network Security Groups, storage encryption, VM security, and more.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'subscription_id': {
                        'type': 'string',
                        'description': 'Azure subscription ID to audit'
                    },
                    'resource_groups': {
                        'type': 'array',
                        'description': 'Specific resource groups to audit',
                        'items': {'type': 'string'}
                    }
                },
                'required': []
            },
            'handler': azure_security_audit
        },
        {
            'name': 'gcp_security_audit',
            'description': (
                'Audit GCP security posture and identify misconfigurations. '
                'Checks Cloud Storage, firewall rules, IAM permissions, and more.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'project_id': {
                        'type': 'string',
                        'description': 'GCP project ID to audit'
                    },
                    'services': {
                        'type': 'array',
                        'description': 'Specific GCP services to audit',
                        'items': {
                            'type': 'string',
                            'enum': ['storage', 'compute', 'iam', 'sql']
                        }
                    }
                },
                'required': []
            },
            'handler': gcp_security_audit
        },
        {
            'name': 'kubernetes_security_audit',
            'description': (
                'Audit Kubernetes cluster security configuration. '
                'Identifies pods running as root, privileged containers, '
                'public services, and other security misconfigurations.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'namespace': {
                        'type': 'string',
                        'description': 'Kubernetes namespace to audit (default: all namespaces)'
                    },
                    'context': {
                        'type': 'string',
                        'description': 'Kubernetes context to use'
                    }
                },
                'required': []
            },
            'handler': kubernetes_security_audit
        },

        # Quick Vulnerability Scan
        {
            'name': 'quick_vulnerability_scan',
            'description': (
                'Perform a quick, optimized vulnerability scan for fast results. '
                'This tool is designed to complete within 2-4 minutes and provides '
                'a security overview without deep penetration testing. '
                'Choose scan_type: "web" for web applications (SSL + Nikto), '
                '"network" for network services (top 100 ports), or '
                '"comprehensive" for both (top 200 ports + web checks). '
                'IMPORTANT: Only use on authorized targets.'
            ),
            'input_schema': {
                'type': 'object',
                'properties': {
                    'target': {
                        'type': 'string',
                        'description': 'Target hostname, IP address, or URL to scan'
                    },
                    'scan_type': {
                        'type': 'string',
                        'description': 'Type of quick scan to perform',
                        'enum': ['web', 'network', 'comprehensive'],
                        'default': 'web'
                    }
                },
                'required': ['target']
            },
            'handler': quick_vulnerability_scan
        }
    ]
